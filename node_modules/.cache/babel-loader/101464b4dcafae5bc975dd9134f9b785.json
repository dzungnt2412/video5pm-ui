{"remainingRequest":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/babel-loader/lib/index.js!/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/cache-loader/dist/cjs.js??ref--0-0!/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/tiendzung/workspace/video5pm/video5pm-ui/uikit/components/autocomplete/Autocomplete.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/uikit/components/autocomplete/Autocomplete.vue","mtime":1604479001997},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/cache-loader/dist/cjs.js","mtime":1604479000133},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/babel-loader/lib/index.js","mtime":1604479000077},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/cache-loader/dist/cjs.js","mtime":1604479000133},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/vue-loader/lib/index.js","mtime":1604479001773}],"contextDependencies":[],"result":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { getValueByPath } from '../../utils/common';\nimport PInput from '../input/Input';\nimport FormElementMixin from '../../mixins/FormElement';\nexport default {\n  name: 'PAutocomplete',\n  components: {\n    PInput: PInput\n  },\n  inheritAttrs: false,\n  mixins: [FormElementMixin],\n  props: {\n    value: [Number, String],\n    data: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    field: {\n      type: String,\n      default: 'value'\n    },\n    keepFirst: Boolean,\n    clearOnSelect: Boolean,\n    openOnFocus: Boolean,\n    customFormatter: Function\n  },\n  data: function data() {\n    return {\n      selected: null,\n      hovered: null,\n      isActive: false,\n      internalVal: this.value,\n      internalAutocomplete: this.autocomplete || 'off',\n      isListInViewportVertically: true,\n      hasFocus: false,\n      isAutocomplete: true,\n      elementRef: 'input'\n    };\n  },\n  computed: {\n    /**\n     * White-listed items to not close when clicked.\n     * Add input, dropdown and all children.\n     */\n    whiteList: function whiteList() {\n      var whiteList = [];\n      whiteList.push(this.$refs.input.$el.querySelector('input'));\n      whiteList.push(this.$refs.dropdown); // Add all chidren from dropdown\n\n      if (this.$refs.dropdown !== undefined) {\n        var children = this.$refs.dropdown.querySelectorAll('*');\n\n        var _iterator = _createForOfIteratorHelper(children),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var child = _step.value;\n            whiteList.push(child);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return whiteList;\n    },\n\n    /**\n     * Check if exists default slot\n     */\n    hasDefaultSlot: function hasDefaultSlot() {\n      return !!this.$scopedSlots.default;\n    },\n\n    /**\n     * Check if exists \"empty\" slot\n     */\n    hasEmptySlot: function hasEmptySlot() {\n      return !!this.$slots.empty;\n    },\n\n    /**\n     * Check if exists \"header\" slot\n     */\n    hasHeaderSlot: function hasHeaderSlot() {\n      return !!this.$slots.header;\n    },\n\n    /**\n     * Check if exists \"footer\" slot\n     */\n    hasFooterSlot: function hasFooterSlot() {\n      return !!this.$slots.footer;\n    }\n  },\n  watch: {\n    /**\n     * When dropdown is toggled, check the visibility to know when\n     * to open upwards.\n     */\n    isActive: function isActive(active) {\n      var _this = this;\n\n      if (active) {\n        this.calcDropdownInViewportVertical();\n      } else {\n        this.$nextTick(function () {\n          return _this.setHovered(null);\n        }); // Timeout to wait for the animation to finish before recalculating\n\n        setTimeout(function () {\n          _this.calcDropdownInViewportVertical();\n        }, 100);\n      }\n    },\n\n    /**\n     * When updating input's value\n     *   1. Emit changes\n     *   2. If value isn't the same as selected, set null\n     *   3. Close dropdown if value is clear or else open it\n     */\n    internalVal: function internalVal(value) {\n      this.$emit('input', value); // Check if selected is invalid\n\n      var currentValue = this.getValue(this.selected);\n\n      if (currentValue && currentValue !== value) {\n        this.setSelected(null, false);\n      } // Close dropdown if input is clear or else open it\n\n\n      if (this.hasFocus && (!this.openOnFocus || value)) {\n        this.isActive = !!value;\n      }\n    },\n\n    /**\n     * When v-model is changed:\n     *   1. Update internal value.\n     *   2. If it's invalid, validate again.\n     */\n    value: function value(_value) {\n      this.internalVal = _value;\n    },\n\n    /**\n     * Select first option if \"keep-first\n     */\n    data: function data(value) {\n      // Keep first option always pre-selected\n      if (this.keepFirst) {\n        this.selectFirstOption(value);\n      }\n    }\n  },\n  methods: {\n    /**\n     * Set which option is currently hovered.\n     */\n    setHovered: function setHovered(option) {\n      if (option === undefined) {\n        return;\n      }\n\n      this.hovered = option;\n    },\n\n    /**\n     * Set which option is currently selected, update v-model,\n     * update input value and close dropdown.\n     */\n    setSelected: function setSelected(option) {\n      var _this2 = this;\n\n      var closeDropdown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (option === undefined) {\n        return;\n      }\n\n      this.selected = option;\n      this.$emit('select', this.selected);\n\n      if (this.selected !== null) {\n        this.internalVal = this.clearOnSelect ? '' : this.getValue(this.selected);\n      }\n\n      closeDropdown && this.$nextTick(function () {\n        _this2.isActive = false;\n      });\n    },\n\n    /**\n     * Select first option\n     */\n    selectFirstOption: function selectFirstOption(options) {\n      var _this3 = this;\n\n      this.$nextTick(function () {\n        if (options.length) {\n          // If has visible data or open on focus, keep updating the hovered\n          if (_this3.openOnFocus || _this3.internalVal !== '' && _this3.hovered !== options[0]) {\n            _this3.setHovered(options[0]);\n          }\n        } else {\n          _this3.setHovered(null);\n        }\n      });\n    },\n\n    /**\n     * Enter key listener.\n     * Select the hovered option.\n     */\n    enterPressed: function enterPressed() {\n      if (this.hovered === null) {\n        return;\n      }\n\n      this.setSelected(this.hovered);\n    },\n\n    /**\n     * Tab key listener.\n     * Select hovered option if it exists, close dropdown, then allow\n     * native handling to move to next tabbable element.\n     */\n    tabPressed: function tabPressed() {\n      if (this.hovered === null) {\n        this.isActive = false;\n        return;\n      }\n\n      this.setSelected(this.hovered);\n    },\n\n    /**\n     * Close dropdown if clicked outside.\n     */\n    clickedOutside: function clickedOutside(event) {\n      if (this.whiteList.indexOf(event.target) < 0) {\n        this.isActive = false;\n      }\n    },\n\n    /**\n     * Return display text for the input.\n     * If object, get value from path, or else just the value.\n     */\n    getValue: function getValue(option) {\n      if (!option) {\n        return;\n      }\n\n      if (typeof this.customFormatter !== 'undefined') {\n        return this.customFormatter(option);\n      }\n\n      return _typeof(option) === 'object' ? getValueByPath(option, this.field) : option;\n    },\n\n    /**\n     * Calculate if the dropdown is vertically visible when activated,\n     * otherwise it is openened upwards.\n     */\n    calcDropdownInViewportVertical: function calcDropdownInViewportVertical() {\n      var _this4 = this;\n\n      this.$nextTick(function () {\n        /**\n         * this.$refs.dropdown may be undefined\n         * when Autocomplete is conditional rendered\n         */\n        if (_this4.$refs.dropdown === undefined) {\n          return;\n        }\n\n        var rect = _this4.$refs.dropdown.getBoundingClientRect();\n\n        _this4.isListInViewportVertically = rect.top >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);\n      });\n    },\n\n    /**\n     * Arrows keys listener.\n     * If dropdown is active, set hovered option, or else just open.\n     */\n    keyArrows: function keyArrows(direction) {\n      var sum = direction === 'down' ? 1 : -1;\n\n      if (this.isActive) {\n        var index = this.data.indexOf(this.hovered) + sum;\n        index = index > this.data.length - 1 ? this.data.length : index;\n        index = index < 0 ? 0 : index;\n        this.setHovered(this.data[index]);\n        var list = this.$refs.dropdown.querySelector('.dropdown-content');\n        var element = list.querySelectorAll('a.dropdown-item:not(.is-disabled)')[index];\n\n        if (!element) {\n          return;\n        }\n\n        var visMin = list.scrollTop;\n        var visMax = list.scrollTop + list.clientHeight - element.clientHeight;\n\n        if (element.offsetTop < visMin) {\n          list.scrollTop = element.offsetTop;\n        } else if (element.offsetTop >= visMax) {\n          list.scrollTop = element.offsetTop - list.clientHeight + element.clientHeight;\n        }\n      } else {\n        this.isActive = true;\n      }\n    },\n\n    /**\n     * Focus listener.\n     * If value is the same as selected, select all text.\n     */\n    focused: function focused(event) {\n      if (this.getValue(this.selected) === this.internalVal) {\n        this.$el.querySelector('input').select();\n      }\n\n      if (this.openOnFocus) {\n        this.isActive = true;\n\n        if (this.keepFirst) {\n          this.selectFirstOption(this.data);\n        }\n      }\n\n      this.hasFocus = true;\n      this.$emit('focus', event);\n    },\n\n    /**\n     * Blur listener.\n     */\n    onBlur: function onBlur(event) {\n      this.hasFocus = false;\n      this.$emit('blur', event);\n    },\n    onInput: function onInput() {\n      var currentValue = this.getValue(this.selected);\n\n      if (currentValue && currentValue === this.internalVal) {\n        return;\n      }\n\n      this.$emit('typing', this.internalVal);\n    }\n  },\n  created: function created() {\n    if (typeof window !== 'undefined') {\n      document.addEventListener('click', this.clickedOutside);\n      window.addEventListener('resize', this.calcDropdownInViewportVertical);\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (typeof window !== 'undefined') {\n      document.removeEventListener('click', this.clickedOutside);\n      window.removeEventListener('resize', this.calcDropdownInViewportVertical);\n    }\n  }\n};",{"version":3,"sources":["Autocomplete.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"p-autocomplete\">\n    <p-input\n      v-model=\"internalVal\"\n      ref=\"input\"\n      type=\"text\"\n      :size=\"size\"\n      :loading=\"loading\"\n      :rounded=\"rounded\"\n      :maxlength=\"maxlength\"\n      :autocomplete=\"internalAutocomplete\"\n      v-bind=\"$attrs\"\n      @input=\"onInput\"\n      @focus=\"focused\"\n      @blur=\"onBlur\"\n      @keyup.native.esc.prevent=\"isActive = false\"\n      @keydown.native.tab=\"tabPressed\"\n      @keydown.native.enter.prevent=\"enterPressed\"\n      @keydown.native.up.prevent=\"keyArrows('up')\"\n      @keydown.native.down.prevent=\"keyArrows('down')\"\n    />\n\n    <transition name=\"fade\">\n      <div\n        class=\"dropdown-menu\"\n        :class=\"{ 'is-opened-top': !isListInViewportVertically }\"\n        v-show=\"isActive && (data.length > 0 || hasEmptySlot || hasHeaderSlot)\"\n        ref=\"dropdown\"\n      >\n        <div class=\"dropdown-content\" v-show=\"isActive\">\n          <div v-if=\"hasHeaderSlot\" class=\"dropdown-item\">\n            <slot name=\"header\" />\n          </div>\n          <a\n            v-for=\"(option, index) in data\"\n            :key=\"index\"\n            class=\"dropdown-item\"\n            :class=\"{ 'is-hovered': option === hovered }\"\n            @click=\"setSelected(option)\"\n          >\n            <slot v-if=\"hasDefaultSlot\" :option=\"option\" :index=\"index\" />\n            <span v-else>\n              {{ getValue(option, true) }}\n            </span>\n          </a>\n          <div\n            v-if=\"data.length === 0 && hasEmptySlot\"\n            class=\"dropdown-item is-disabled\"\n          >\n            <slot name=\"empty\" />\n          </div>\n          <div v-if=\"hasFooterSlot\" class=\"dropdown-item\">\n            <slot name=\"footer\" />\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport { getValueByPath } from '../../utils/common'\nimport PInput from '../input/Input'\nimport FormElementMixin from '../../mixins/FormElement'\n\nexport default {\n  name: 'PAutocomplete',\n  components: {\n    PInput,\n  },\n  inheritAttrs: false,\n  mixins: [FormElementMixin],\n  props: {\n    value: [Number, String],\n    data: {\n      type: Array,\n      default: () => [],\n    },\n    field: {\n      type: String,\n      default: 'value',\n    },\n    keepFirst: Boolean,\n    clearOnSelect: Boolean,\n    openOnFocus: Boolean,\n    customFormatter: Function,\n  },\n  data() {\n    return {\n      selected: null,\n      hovered: null,\n      isActive: false,\n      internalVal: this.value,\n      internalAutocomplete: this.autocomplete || 'off',\n      isListInViewportVertically: true,\n      hasFocus: false,\n      isAutocomplete: true,\n      elementRef: 'input',\n    }\n  },\n  computed: {\n    /**\n     * White-listed items to not close when clicked.\n     * Add input, dropdown and all children.\n     */\n    whiteList() {\n      const whiteList = []\n      whiteList.push(this.$refs.input.$el.querySelector('input'))\n      whiteList.push(this.$refs.dropdown)\n      // Add all chidren from dropdown\n      if (this.$refs.dropdown !== undefined) {\n        const children = this.$refs.dropdown.querySelectorAll('*')\n        for (const child of children) {\n          whiteList.push(child)\n        }\n      }\n\n      return whiteList\n    },\n\n    /**\n     * Check if exists default slot\n     */\n    hasDefaultSlot() {\n      return !!this.$scopedSlots.default\n    },\n\n    /**\n     * Check if exists \"empty\" slot\n     */\n    hasEmptySlot() {\n      return !!this.$slots.empty\n    },\n\n    /**\n     * Check if exists \"header\" slot\n     */\n    hasHeaderSlot() {\n      return !!this.$slots.header\n    },\n\n    /**\n     * Check if exists \"footer\" slot\n     */\n    hasFooterSlot() {\n      return !!this.$slots.footer\n    },\n  },\n  watch: {\n    /**\n     * When dropdown is toggled, check the visibility to know when\n     * to open upwards.\n     */\n    isActive(active) {\n      if (active) {\n        this.calcDropdownInViewportVertical()\n      } else {\n        this.$nextTick(() => this.setHovered(null))\n        // Timeout to wait for the animation to finish before recalculating\n        setTimeout(() => {\n          this.calcDropdownInViewportVertical()\n        }, 100)\n      }\n    },\n\n    /**\n     * When updating input's value\n     *   1. Emit changes\n     *   2. If value isn't the same as selected, set null\n     *   3. Close dropdown if value is clear or else open it\n     */\n    internalVal(value) {\n      this.$emit('input', value)\n      // Check if selected is invalid\n      const currentValue = this.getValue(this.selected)\n\n      if (currentValue && currentValue !== value) {\n        this.setSelected(null, false)\n      }\n\n      // Close dropdown if input is clear or else open it\n      if (this.hasFocus && (!this.openOnFocus || value)) {\n        this.isActive = !!value\n      }\n    },\n\n    /**\n     * When v-model is changed:\n     *   1. Update internal value.\n     *   2. If it's invalid, validate again.\n     */\n    value(value) {\n      this.internalVal = value\n    },\n\n    /**\n     * Select first option if \"keep-first\n     */\n    data(value) {\n      // Keep first option always pre-selected\n      if (this.keepFirst) {\n        this.selectFirstOption(value)\n      }\n    },\n  },\n  methods: {\n    /**\n     * Set which option is currently hovered.\n     */\n    setHovered(option) {\n      if (option === undefined) {\n        return\n      }\n\n      this.hovered = option\n    },\n\n    /**\n     * Set which option is currently selected, update v-model,\n     * update input value and close dropdown.\n     */\n    setSelected(option, closeDropdown = true) {\n      if (option === undefined) {\n        return\n      }\n\n      this.selected = option\n      this.$emit('select', this.selected)\n\n      if (this.selected !== null) {\n        this.internalVal = this.clearOnSelect\n          ? ''\n          : this.getValue(this.selected)\n      }\n\n      closeDropdown &&\n        this.$nextTick(() => {\n          this.isActive = false\n        })\n    },\n\n    /**\n     * Select first option\n     */\n    selectFirstOption(options) {\n      this.$nextTick(() => {\n        if (options.length) {\n          // If has visible data or open on focus, keep updating the hovered\n          if (\n            this.openOnFocus ||\n            (this.internalVal !== '' && this.hovered !== options[0])\n          ) {\n            this.setHovered(options[0])\n          }\n        } else {\n          this.setHovered(null)\n        }\n      })\n    },\n\n    /**\n     * Enter key listener.\n     * Select the hovered option.\n     */\n    enterPressed() {\n      if (this.hovered === null) {\n        return\n      }\n\n      this.setSelected(this.hovered)\n    },\n\n    /**\n     * Tab key listener.\n     * Select hovered option if it exists, close dropdown, then allow\n     * native handling to move to next tabbable element.\n     */\n    tabPressed() {\n      if (this.hovered === null) {\n        this.isActive = false\n        return\n      }\n\n      this.setSelected(this.hovered)\n    },\n\n    /**\n     * Close dropdown if clicked outside.\n     */\n    clickedOutside(event) {\n      if (this.whiteList.indexOf(event.target) < 0) {\n        this.isActive = false\n      }\n    },\n\n    /**\n     * Return display text for the input.\n     * If object, get value from path, or else just the value.\n     */\n    getValue(option) {\n      if (!option) {\n        return\n      }\n\n      if (typeof this.customFormatter !== 'undefined') {\n        return this.customFormatter(option)\n      }\n\n      return typeof option === 'object'\n        ? getValueByPath(option, this.field)\n        : option\n    },\n\n    /**\n     * Calculate if the dropdown is vertically visible when activated,\n     * otherwise it is openened upwards.\n     */\n    calcDropdownInViewportVertical() {\n      this.$nextTick(() => {\n        /**\n         * this.$refs.dropdown may be undefined\n         * when Autocomplete is conditional rendered\n         */\n        if (this.$refs.dropdown === undefined) {\n          return\n        }\n\n        const rect = this.$refs.dropdown.getBoundingClientRect()\n\n        this.isListInViewportVertically =\n          rect.top >= 0 &&\n          rect.bottom <=\n            (window.innerHeight || document.documentElement.clientHeight)\n      })\n    },\n\n    /**\n     * Arrows keys listener.\n     * If dropdown is active, set hovered option, or else just open.\n     */\n    keyArrows(direction) {\n      const sum = direction === 'down' ? 1 : -1\n\n      if (this.isActive) {\n        let index = this.data.indexOf(this.hovered) + sum\n        index = index > this.data.length - 1 ? this.data.length : index\n        index = index < 0 ? 0 : index\n\n        this.setHovered(this.data[index])\n\n        const list = this.$refs.dropdown.querySelector('.dropdown-content')\n        const element = list.querySelectorAll(\n          'a.dropdown-item:not(.is-disabled)'\n        )[index]\n\n        if (!element) {\n          return\n        }\n\n        const visMin = list.scrollTop\n        const visMax = list.scrollTop + list.clientHeight - element.clientHeight\n\n        if (element.offsetTop < visMin) {\n          list.scrollTop = element.offsetTop\n        } else if (element.offsetTop >= visMax) {\n          list.scrollTop =\n            element.offsetTop - list.clientHeight + element.clientHeight\n        }\n      } else {\n        this.isActive = true\n      }\n    },\n\n    /**\n     * Focus listener.\n     * If value is the same as selected, select all text.\n     */\n    focused(event) {\n      if (this.getValue(this.selected) === this.internalVal) {\n        this.$el.querySelector('input').select()\n      }\n\n      if (this.openOnFocus) {\n        this.isActive = true\n        if (this.keepFirst) {\n          this.selectFirstOption(this.data)\n        }\n      }\n\n      this.hasFocus = true\n      this.$emit('focus', event)\n    },\n\n    /**\n     * Blur listener.\n     */\n    onBlur(event) {\n      this.hasFocus = false\n      this.$emit('blur', event)\n    },\n\n    onInput() {\n      const currentValue = this.getValue(this.selected)\n\n      if (currentValue && currentValue === this.internalVal) {\n        return\n      }\n\n      this.$emit('typing', this.internalVal)\n    },\n  },\n  created() {\n    if (typeof window !== 'undefined') {\n      document.addEventListener('click', this.clickedOutside)\n      window.addEventListener('resize', this.calcDropdownInViewportVertical)\n    }\n  },\n  beforeDestroy() {\n    if (typeof window !== 'undefined') {\n      document.removeEventListener('click', this.clickedOutside)\n      window.removeEventListener('resize', this.calcDropdownInViewportVertical)\n    }\n  },\n}\n</script>\n"],"sourceRoot":"uikit/components/autocomplete"}]}