{"remainingRequest":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/tiendzung/workspace/video5pm/video5pm-ui/uikit/components/autocomplete/Autocomplete.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/uikit/components/autocomplete/Autocomplete.vue","mtime":1604479001997},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/cache-loader/dist/cjs.js","mtime":1604479000133},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/babel-loader/lib/index.js","mtime":1604479000077},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/cache-loader/dist/cjs.js","mtime":1604479000133},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/vue-loader/lib/index.js","mtime":1604479001773}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { getValueByPath } from '../../utils/common'\nimport PInput from '../input/Input'\nimport FormElementMixin from '../../mixins/FormElement'\n\nexport default {\n  name: 'PAutocomplete',\n  components: {\n    PInput,\n  },\n  inheritAttrs: false,\n  mixins: [FormElementMixin],\n  props: {\n    value: [Number, String],\n    data: {\n      type: Array,\n      default: () => [],\n    },\n    field: {\n      type: String,\n      default: 'value',\n    },\n    keepFirst: Boolean,\n    clearOnSelect: Boolean,\n    openOnFocus: Boolean,\n    customFormatter: Function,\n  },\n  data() {\n    return {\n      selected: null,\n      hovered: null,\n      isActive: false,\n      internalVal: this.value,\n      internalAutocomplete: this.autocomplete || 'off',\n      isListInViewportVertically: true,\n      hasFocus: false,\n      isAutocomplete: true,\n      elementRef: 'input',\n    }\n  },\n  computed: {\n    /**\n     * White-listed items to not close when clicked.\n     * Add input, dropdown and all children.\n     */\n    whiteList() {\n      const whiteList = []\n      whiteList.push(this.$refs.input.$el.querySelector('input'))\n      whiteList.push(this.$refs.dropdown)\n      // Add all chidren from dropdown\n      if (this.$refs.dropdown !== undefined) {\n        const children = this.$refs.dropdown.querySelectorAll('*')\n        for (const child of children) {\n          whiteList.push(child)\n        }\n      }\n\n      return whiteList\n    },\n\n    /**\n     * Check if exists default slot\n     */\n    hasDefaultSlot() {\n      return !!this.$scopedSlots.default\n    },\n\n    /**\n     * Check if exists \"empty\" slot\n     */\n    hasEmptySlot() {\n      return !!this.$slots.empty\n    },\n\n    /**\n     * Check if exists \"header\" slot\n     */\n    hasHeaderSlot() {\n      return !!this.$slots.header\n    },\n\n    /**\n     * Check if exists \"footer\" slot\n     */\n    hasFooterSlot() {\n      return !!this.$slots.footer\n    },\n  },\n  watch: {\n    /**\n     * When dropdown is toggled, check the visibility to know when\n     * to open upwards.\n     */\n    isActive(active) {\n      if (active) {\n        this.calcDropdownInViewportVertical()\n      } else {\n        this.$nextTick(() => this.setHovered(null))\n        // Timeout to wait for the animation to finish before recalculating\n        setTimeout(() => {\n          this.calcDropdownInViewportVertical()\n        }, 100)\n      }\n    },\n\n    /**\n     * When updating input's value\n     *   1. Emit changes\n     *   2. If value isn't the same as selected, set null\n     *   3. Close dropdown if value is clear or else open it\n     */\n    internalVal(value) {\n      this.$emit('input', value)\n      // Check if selected is invalid\n      const currentValue = this.getValue(this.selected)\n\n      if (currentValue && currentValue !== value) {\n        this.setSelected(null, false)\n      }\n\n      // Close dropdown if input is clear or else open it\n      if (this.hasFocus && (!this.openOnFocus || value)) {\n        this.isActive = !!value\n      }\n    },\n\n    /**\n     * When v-model is changed:\n     *   1. Update internal value.\n     *   2. If it's invalid, validate again.\n     */\n    value(value) {\n      this.internalVal = value\n    },\n\n    /**\n     * Select first option if \"keep-first\n     */\n    data(value) {\n      // Keep first option always pre-selected\n      if (this.keepFirst) {\n        this.selectFirstOption(value)\n      }\n    },\n  },\n  methods: {\n    /**\n     * Set which option is currently hovered.\n     */\n    setHovered(option) {\n      if (option === undefined) {\n        return\n      }\n\n      this.hovered = option\n    },\n\n    /**\n     * Set which option is currently selected, update v-model,\n     * update input value and close dropdown.\n     */\n    setSelected(option, closeDropdown = true) {\n      if (option === undefined) {\n        return\n      }\n\n      this.selected = option\n      this.$emit('select', this.selected)\n\n      if (this.selected !== null) {\n        this.internalVal = this.clearOnSelect\n          ? ''\n          : this.getValue(this.selected)\n      }\n\n      closeDropdown &&\n        this.$nextTick(() => {\n          this.isActive = false\n        })\n    },\n\n    /**\n     * Select first option\n     */\n    selectFirstOption(options) {\n      this.$nextTick(() => {\n        if (options.length) {\n          // If has visible data or open on focus, keep updating the hovered\n          if (\n            this.openOnFocus ||\n            (this.internalVal !== '' && this.hovered !== options[0])\n          ) {\n            this.setHovered(options[0])\n          }\n        } else {\n          this.setHovered(null)\n        }\n      })\n    },\n\n    /**\n     * Enter key listener.\n     * Select the hovered option.\n     */\n    enterPressed() {\n      if (this.hovered === null) {\n        return\n      }\n\n      this.setSelected(this.hovered)\n    },\n\n    /**\n     * Tab key listener.\n     * Select hovered option if it exists, close dropdown, then allow\n     * native handling to move to next tabbable element.\n     */\n    tabPressed() {\n      if (this.hovered === null) {\n        this.isActive = false\n        return\n      }\n\n      this.setSelected(this.hovered)\n    },\n\n    /**\n     * Close dropdown if clicked outside.\n     */\n    clickedOutside(event) {\n      if (this.whiteList.indexOf(event.target) < 0) {\n        this.isActive = false\n      }\n    },\n\n    /**\n     * Return display text for the input.\n     * If object, get value from path, or else just the value.\n     */\n    getValue(option) {\n      if (!option) {\n        return\n      }\n\n      if (typeof this.customFormatter !== 'undefined') {\n        return this.customFormatter(option)\n      }\n\n      return typeof option === 'object'\n        ? getValueByPath(option, this.field)\n        : option\n    },\n\n    /**\n     * Calculate if the dropdown is vertically visible when activated,\n     * otherwise it is openened upwards.\n     */\n    calcDropdownInViewportVertical() {\n      this.$nextTick(() => {\n        /**\n         * this.$refs.dropdown may be undefined\n         * when Autocomplete is conditional rendered\n         */\n        if (this.$refs.dropdown === undefined) {\n          return\n        }\n\n        const rect = this.$refs.dropdown.getBoundingClientRect()\n\n        this.isListInViewportVertically =\n          rect.top >= 0 &&\n          rect.bottom <=\n            (window.innerHeight || document.documentElement.clientHeight)\n      })\n    },\n\n    /**\n     * Arrows keys listener.\n     * If dropdown is active, set hovered option, or else just open.\n     */\n    keyArrows(direction) {\n      const sum = direction === 'down' ? 1 : -1\n\n      if (this.isActive) {\n        let index = this.data.indexOf(this.hovered) + sum\n        index = index > this.data.length - 1 ? this.data.length : index\n        index = index < 0 ? 0 : index\n\n        this.setHovered(this.data[index])\n\n        const list = this.$refs.dropdown.querySelector('.dropdown-content')\n        const element = list.querySelectorAll(\n          'a.dropdown-item:not(.is-disabled)'\n        )[index]\n\n        if (!element) {\n          return\n        }\n\n        const visMin = list.scrollTop\n        const visMax = list.scrollTop + list.clientHeight - element.clientHeight\n\n        if (element.offsetTop < visMin) {\n          list.scrollTop = element.offsetTop\n        } else if (element.offsetTop >= visMax) {\n          list.scrollTop =\n            element.offsetTop - list.clientHeight + element.clientHeight\n        }\n      } else {\n        this.isActive = true\n      }\n    },\n\n    /**\n     * Focus listener.\n     * If value is the same as selected, select all text.\n     */\n    focused(event) {\n      if (this.getValue(this.selected) === this.internalVal) {\n        this.$el.querySelector('input').select()\n      }\n\n      if (this.openOnFocus) {\n        this.isActive = true\n        if (this.keepFirst) {\n          this.selectFirstOption(this.data)\n        }\n      }\n\n      this.hasFocus = true\n      this.$emit('focus', event)\n    },\n\n    /**\n     * Blur listener.\n     */\n    onBlur(event) {\n      this.hasFocus = false\n      this.$emit('blur', event)\n    },\n\n    onInput() {\n      const currentValue = this.getValue(this.selected)\n\n      if (currentValue && currentValue === this.internalVal) {\n        return\n      }\n\n      this.$emit('typing', this.internalVal)\n    },\n  },\n  created() {\n    if (typeof window !== 'undefined') {\n      document.addEventListener('click', this.clickedOutside)\n      window.addEventListener('resize', this.calcDropdownInViewportVertical)\n    }\n  },\n  beforeDestroy() {\n    if (typeof window !== 'undefined') {\n      document.removeEventListener('click', this.clickedOutside)\n      window.removeEventListener('resize', this.calcDropdownInViewportVertical)\n    }\n  },\n}\n",{"version":3,"sources":["Autocomplete.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Autocomplete.vue","sourceRoot":"uikit/components/autocomplete","sourcesContent":["<template>\n  <div class=\"p-autocomplete\">\n    <p-input\n      v-model=\"internalVal\"\n      ref=\"input\"\n      type=\"text\"\n      :size=\"size\"\n      :loading=\"loading\"\n      :rounded=\"rounded\"\n      :maxlength=\"maxlength\"\n      :autocomplete=\"internalAutocomplete\"\n      v-bind=\"$attrs\"\n      @input=\"onInput\"\n      @focus=\"focused\"\n      @blur=\"onBlur\"\n      @keyup.native.esc.prevent=\"isActive = false\"\n      @keydown.native.tab=\"tabPressed\"\n      @keydown.native.enter.prevent=\"enterPressed\"\n      @keydown.native.up.prevent=\"keyArrows('up')\"\n      @keydown.native.down.prevent=\"keyArrows('down')\"\n    />\n\n    <transition name=\"fade\">\n      <div\n        class=\"dropdown-menu\"\n        :class=\"{ 'is-opened-top': !isListInViewportVertically }\"\n        v-show=\"isActive && (data.length > 0 || hasEmptySlot || hasHeaderSlot)\"\n        ref=\"dropdown\"\n      >\n        <div class=\"dropdown-content\" v-show=\"isActive\">\n          <div v-if=\"hasHeaderSlot\" class=\"dropdown-item\">\n            <slot name=\"header\" />\n          </div>\n          <a\n            v-for=\"(option, index) in data\"\n            :key=\"index\"\n            class=\"dropdown-item\"\n            :class=\"{ 'is-hovered': option === hovered }\"\n            @click=\"setSelected(option)\"\n          >\n            <slot v-if=\"hasDefaultSlot\" :option=\"option\" :index=\"index\" />\n            <span v-else>\n              {{ getValue(option, true) }}\n            </span>\n          </a>\n          <div\n            v-if=\"data.length === 0 && hasEmptySlot\"\n            class=\"dropdown-item is-disabled\"\n          >\n            <slot name=\"empty\" />\n          </div>\n          <div v-if=\"hasFooterSlot\" class=\"dropdown-item\">\n            <slot name=\"footer\" />\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport { getValueByPath } from '../../utils/common'\nimport PInput from '../input/Input'\nimport FormElementMixin from '../../mixins/FormElement'\n\nexport default {\n  name: 'PAutocomplete',\n  components: {\n    PInput,\n  },\n  inheritAttrs: false,\n  mixins: [FormElementMixin],\n  props: {\n    value: [Number, String],\n    data: {\n      type: Array,\n      default: () => [],\n    },\n    field: {\n      type: String,\n      default: 'value',\n    },\n    keepFirst: Boolean,\n    clearOnSelect: Boolean,\n    openOnFocus: Boolean,\n    customFormatter: Function,\n  },\n  data() {\n    return {\n      selected: null,\n      hovered: null,\n      isActive: false,\n      internalVal: this.value,\n      internalAutocomplete: this.autocomplete || 'off',\n      isListInViewportVertically: true,\n      hasFocus: false,\n      isAutocomplete: true,\n      elementRef: 'input',\n    }\n  },\n  computed: {\n    /**\n     * White-listed items to not close when clicked.\n     * Add input, dropdown and all children.\n     */\n    whiteList() {\n      const whiteList = []\n      whiteList.push(this.$refs.input.$el.querySelector('input'))\n      whiteList.push(this.$refs.dropdown)\n      // Add all chidren from dropdown\n      if (this.$refs.dropdown !== undefined) {\n        const children = this.$refs.dropdown.querySelectorAll('*')\n        for (const child of children) {\n          whiteList.push(child)\n        }\n      }\n\n      return whiteList\n    },\n\n    /**\n     * Check if exists default slot\n     */\n    hasDefaultSlot() {\n      return !!this.$scopedSlots.default\n    },\n\n    /**\n     * Check if exists \"empty\" slot\n     */\n    hasEmptySlot() {\n      return !!this.$slots.empty\n    },\n\n    /**\n     * Check if exists \"header\" slot\n     */\n    hasHeaderSlot() {\n      return !!this.$slots.header\n    },\n\n    /**\n     * Check if exists \"footer\" slot\n     */\n    hasFooterSlot() {\n      return !!this.$slots.footer\n    },\n  },\n  watch: {\n    /**\n     * When dropdown is toggled, check the visibility to know when\n     * to open upwards.\n     */\n    isActive(active) {\n      if (active) {\n        this.calcDropdownInViewportVertical()\n      } else {\n        this.$nextTick(() => this.setHovered(null))\n        // Timeout to wait for the animation to finish before recalculating\n        setTimeout(() => {\n          this.calcDropdownInViewportVertical()\n        }, 100)\n      }\n    },\n\n    /**\n     * When updating input's value\n     *   1. Emit changes\n     *   2. If value isn't the same as selected, set null\n     *   3. Close dropdown if value is clear or else open it\n     */\n    internalVal(value) {\n      this.$emit('input', value)\n      // Check if selected is invalid\n      const currentValue = this.getValue(this.selected)\n\n      if (currentValue && currentValue !== value) {\n        this.setSelected(null, false)\n      }\n\n      // Close dropdown if input is clear or else open it\n      if (this.hasFocus && (!this.openOnFocus || value)) {\n        this.isActive = !!value\n      }\n    },\n\n    /**\n     * When v-model is changed:\n     *   1. Update internal value.\n     *   2. If it's invalid, validate again.\n     */\n    value(value) {\n      this.internalVal = value\n    },\n\n    /**\n     * Select first option if \"keep-first\n     */\n    data(value) {\n      // Keep first option always pre-selected\n      if (this.keepFirst) {\n        this.selectFirstOption(value)\n      }\n    },\n  },\n  methods: {\n    /**\n     * Set which option is currently hovered.\n     */\n    setHovered(option) {\n      if (option === undefined) {\n        return\n      }\n\n      this.hovered = option\n    },\n\n    /**\n     * Set which option is currently selected, update v-model,\n     * update input value and close dropdown.\n     */\n    setSelected(option, closeDropdown = true) {\n      if (option === undefined) {\n        return\n      }\n\n      this.selected = option\n      this.$emit('select', this.selected)\n\n      if (this.selected !== null) {\n        this.internalVal = this.clearOnSelect\n          ? ''\n          : this.getValue(this.selected)\n      }\n\n      closeDropdown &&\n        this.$nextTick(() => {\n          this.isActive = false\n        })\n    },\n\n    /**\n     * Select first option\n     */\n    selectFirstOption(options) {\n      this.$nextTick(() => {\n        if (options.length) {\n          // If has visible data or open on focus, keep updating the hovered\n          if (\n            this.openOnFocus ||\n            (this.internalVal !== '' && this.hovered !== options[0])\n          ) {\n            this.setHovered(options[0])\n          }\n        } else {\n          this.setHovered(null)\n        }\n      })\n    },\n\n    /**\n     * Enter key listener.\n     * Select the hovered option.\n     */\n    enterPressed() {\n      if (this.hovered === null) {\n        return\n      }\n\n      this.setSelected(this.hovered)\n    },\n\n    /**\n     * Tab key listener.\n     * Select hovered option if it exists, close dropdown, then allow\n     * native handling to move to next tabbable element.\n     */\n    tabPressed() {\n      if (this.hovered === null) {\n        this.isActive = false\n        return\n      }\n\n      this.setSelected(this.hovered)\n    },\n\n    /**\n     * Close dropdown if clicked outside.\n     */\n    clickedOutside(event) {\n      if (this.whiteList.indexOf(event.target) < 0) {\n        this.isActive = false\n      }\n    },\n\n    /**\n     * Return display text for the input.\n     * If object, get value from path, or else just the value.\n     */\n    getValue(option) {\n      if (!option) {\n        return\n      }\n\n      if (typeof this.customFormatter !== 'undefined') {\n        return this.customFormatter(option)\n      }\n\n      return typeof option === 'object'\n        ? getValueByPath(option, this.field)\n        : option\n    },\n\n    /**\n     * Calculate if the dropdown is vertically visible when activated,\n     * otherwise it is openened upwards.\n     */\n    calcDropdownInViewportVertical() {\n      this.$nextTick(() => {\n        /**\n         * this.$refs.dropdown may be undefined\n         * when Autocomplete is conditional rendered\n         */\n        if (this.$refs.dropdown === undefined) {\n          return\n        }\n\n        const rect = this.$refs.dropdown.getBoundingClientRect()\n\n        this.isListInViewportVertically =\n          rect.top >= 0 &&\n          rect.bottom <=\n            (window.innerHeight || document.documentElement.clientHeight)\n      })\n    },\n\n    /**\n     * Arrows keys listener.\n     * If dropdown is active, set hovered option, or else just open.\n     */\n    keyArrows(direction) {\n      const sum = direction === 'down' ? 1 : -1\n\n      if (this.isActive) {\n        let index = this.data.indexOf(this.hovered) + sum\n        index = index > this.data.length - 1 ? this.data.length : index\n        index = index < 0 ? 0 : index\n\n        this.setHovered(this.data[index])\n\n        const list = this.$refs.dropdown.querySelector('.dropdown-content')\n        const element = list.querySelectorAll(\n          'a.dropdown-item:not(.is-disabled)'\n        )[index]\n\n        if (!element) {\n          return\n        }\n\n        const visMin = list.scrollTop\n        const visMax = list.scrollTop + list.clientHeight - element.clientHeight\n\n        if (element.offsetTop < visMin) {\n          list.scrollTop = element.offsetTop\n        } else if (element.offsetTop >= visMax) {\n          list.scrollTop =\n            element.offsetTop - list.clientHeight + element.clientHeight\n        }\n      } else {\n        this.isActive = true\n      }\n    },\n\n    /**\n     * Focus listener.\n     * If value is the same as selected, select all text.\n     */\n    focused(event) {\n      if (this.getValue(this.selected) === this.internalVal) {\n        this.$el.querySelector('input').select()\n      }\n\n      if (this.openOnFocus) {\n        this.isActive = true\n        if (this.keepFirst) {\n          this.selectFirstOption(this.data)\n        }\n      }\n\n      this.hasFocus = true\n      this.$emit('focus', event)\n    },\n\n    /**\n     * Blur listener.\n     */\n    onBlur(event) {\n      this.hasFocus = false\n      this.$emit('blur', event)\n    },\n\n    onInput() {\n      const currentValue = this.getValue(this.selected)\n\n      if (currentValue && currentValue === this.internalVal) {\n        return\n      }\n\n      this.$emit('typing', this.internalVal)\n    },\n  },\n  created() {\n    if (typeof window !== 'undefined') {\n      document.addEventListener('click', this.clickedOutside)\n      window.addEventListener('resize', this.calcDropdownInViewportVertical)\n    }\n  },\n  beforeDestroy() {\n    if (typeof window !== 'undefined') {\n      document.removeEventListener('click', this.clickedOutside)\n      window.removeEventListener('resize', this.calcDropdownInViewportVertical)\n    }\n  },\n}\n</script>\n"]}]}