{"remainingRequest":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/tiendzung/workspace/video5pm/video5pm-ui/src/packages/ticket/views/View.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/src/packages/ticket/views/View.vue","mtime":1604479001989},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/babel-loader/lib/index.js","mtime":1604479000077},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/cache-loader/dist/cjs.js","mtime":1604479000133},{"path":"/home/tiendzung/workspace/video5pm/video5pm-ui/node_modules/vue-loader/lib/index.js","mtime":1604479001773}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { mapState, mapActions, mapMutations } from 'vuex'\nimport mixinRoute from '@core/mixins/route'\nimport ModalImage from './components/ModalImage'\nimport mixinTicket from '../mixins/ticket'\nimport mixinUpload from '@/core/mixins/upload'\nimport Browser from '@core/helpers/browser'\nimport { cloneDeep } from '@core/utils'\nexport default {\n  name: 'TicketView',\n  mixins: [mixinRoute, mixinUpload, mixinTicket],\n  components: { ModalImage },\n  data() {\n    return {\n      isChange: false,\n      isHideReply: true,\n      isMessageSending: false,\n      isFetching: false,\n      imageZoomImage: '',\n      isZoomImage: false,\n      result: {},\n      filter: {\n        page: 1,\n        limit: 50,\n      },\n      form: {\n        ticket_id: 0,\n        message: '',\n        urls: [],\n      },\n      attach_files: [],\n    }\n  },\n  computed: {\n    ...mapState('auth', {\n      auth: (state) => state.user,\n    }),\n    ...mapState('ticket', {\n      ticket: (state) => state.ticket,\n      messages: (state) => state.messages,\n      count: (state) => state.count,\n    }),\n    createrName() {\n      if (this.ticket.creater) {\n        return this.ticket.creater.ful_name || this.ticket.creater.username\n      }\n\n      return 'Undefined'\n    },\n\n    ticketID() {\n      return parseInt(this.$route.params.id, 10)\n    },\n\n    isClosed() {\n      return this.ticket.status === 'closed'\n    },\n  },\n  created() {\n    this.filter = this.getRouteQuery()\n    this.init()\n  },\n  methods: {\n    ...mapActions('ticket', [\n      'fetchTicket',\n      'fetchTicketFile',\n      'fetchTicketMessages',\n      'pushMessage',\n      'closeTicket',\n      'fetchTicketStatictis',\n    ]),\n    ...mapMutations(['updateTicketMessage']),\n    async init() {\n      await Promise.all([\n        this.handlerFetchTicket(),\n        this.handlerFetchTicketMessages(),\n      ])\n\n      if (this.ticket.status === 'closed') {\n        this.isHideReply = false\n      }\n      if (this.ticket.attach_files) {\n        this.$set(this, 'attach_files', cloneDeep(this.ticket.attach_files))\n      }\n\n      this.getTicketFiles()\n    },\n    async getTicketFile(url, isFile) {\n      let result\n\n      this.isFetching = true\n      try {\n        const payload = {\n          url: url,\n          type: 'tickets',\n        }\n        result = await this.fetchTicketFile(payload)\n\n        if (!result.success) {\n          this.$toast.open({ type: 'error', message: `Download failed ! ` })\n          return false\n        }\n      } catch (e) {\n        this.$toast.open({ type: 'error', message: `Download failed !` })\n      }\n      this.isFetching = false\n\n      if (isFile) {\n        Browser.downloadBlob(result.blob, url.split('/').pop())\n      } else {\n        return window.URL.createObjectURL(result.blob)\n      }\n    },\n    getTicketFiles() {\n      if (!this.attach_files.length) return false\n      this.attach_files.forEach(async (el, i) => {\n        if (this.isImage(el)) {\n          let result = this.getTicketFile(el, false)\n          result.then((response) => {\n            this.$set(this.attach_files, i, {\n              url: el,\n              blob: response,\n            })\n          })\n        }\n      })\n    },\n    async handlerFetchTicket() {\n      await this.fetchTicket(this.ticketID)\n    },\n\n    async handlerFetchTicketMessages() {\n      this.isFetching = true\n      await this.fetchTicketMessages(this.ticketID, this.filter)\n      this.messages.forEach((el, index) => {\n        let files = el.attach_files\n        if (!files) {\n          return\n        }\n        files.forEach((file, i) => {\n          if (this.isImage(file)) {\n            let result = this.getTicketFile(file, false)\n            result.then(\n              function(response) {\n                this.messages[index].attach_files[i] = {\n                  url: file,\n                  blob: response,\n                }\n                this.$store.commit(\n                  'ticket/updateTicketMessage',\n                  cloneDeep(this.messages)\n                )\n              }.bind(this)\n            )\n          }\n        })\n      })\n      this.isFetching = false\n    },\n\n    async handlerPushMessage() {\n      this.form.urls = this.files.map((item) => item.url)\n      const validate = await this.$validator.validateAll()\n      if (!validate) {\n        return\n      }\n\n      this.form.ticket_id = this.ticketID\n\n      this.isMessageSending = true\n      const result = await this.pushMessage(this.form)\n\n      if (result && result.success) {\n        this.handlerFetchTicketMessages()\n        if (this.ticket.status === 'closed') {\n          this.handlerFetchTicket()\n          await this.fetchTicketStatictis()\n        }\n        this.clearFrom()\n        this.$toast.open({\n          type: 'success',\n          message: 'Gửi tin thành công',\n        })\n      } else {\n        this.$toast.open({ type: 'error', message: result.message })\n      }\n      this.isMessageSending = false\n    },\n\n    clearFrom() {\n      this.files = []\n      this.form = {\n        ticket_id: 0,\n        message: '',\n        urls: [],\n      }\n    },\n\n    zoomImage(src) {\n      this.isZoomImage = true\n      this.imageZoomImage = src\n    },\n\n    showDeleteConfirmation(item) {\n      this.$dialog.confirm({\n        title: `Xác nhận xóa file đính kèm?`,\n        message: `Bạn có chắc chắn muốn xóa file đính kèm này?`,\n        confirmText: 'Xóa',\n        onConfirm: () => this.handleDeleteImage(item),\n        type: 'danger',\n      })\n    },\n\n    handlerForword(staff) {\n      const idx = this.ticket.staffs.find((item) => item.staff_id == staff.id)\n      if (idx) {\n        this.$toast.open({\n          type: 'warning',\n          message: `Ticket đã được chuyển tiếp cho ${staff.full_name ||\n            staff.username}`,\n        })\n        return\n      }\n      this.$dialog.confirm({\n        title: `Chuyển tiếp ticket`,\n        message: `Bạn muốn chuyển tiếp ticket cho ${staff.full_name ||\n          staff.username}`,\n        confirmText: 'Xác nhận',\n        onConfirm: () => {\n          this.handlerForward('', staff.id)\n        },\n        type: 'primary',\n      })\n    },\n  },\n}\n",null]}